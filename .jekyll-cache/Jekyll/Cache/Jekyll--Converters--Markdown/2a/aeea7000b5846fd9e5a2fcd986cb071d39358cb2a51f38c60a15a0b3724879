I"‰_<p><a href="https://docs.google.com/presentation/d/1P5f-cK4jlhGQIfPQ_vaYFRWV464kBb5UaUBkfRjBp4Y/edit">Slide Deck for this workshop</a></p>

<h2 id="plugin-system">Plugin System</h2>

<h3 id="tapable-plugin-system">Tapable Plugin System</h3>

<p>All of Webpack is made of plugins! And to really understand this it helps to understand what the architecture is and what you can plug into. But what is Tapable? It was originally a ~200 line plugin library, but it was rewritten for Webpack 4. Tapable is the entire backbone of Webpack. Tapable is Webpack‚Äôs plugin system. It is how plugins are written and registered, it‚Äôs how Webpack adds any functionality that you could ever think of.</p>

<p>A Tapable instance is a class / object that extends Tapable AKA something you can plug into! You can extend, modify, or change behavior.</p>

<h3 id="compiler--compilation">Compiler &amp; Compilation</h3>

<p>There are 7(ish) Tapable instances AKA classes that you can tap into in Webpack. You can find the files for these in the Webpack <code class="language-plaintext highlighter-rouge">node_modules</code> folder, each instance will have a file that matches it‚Äôs name; i.e. compiler instance <code class="language-plaintext highlighter-rouge">Compiler.js</code></p>

<p>The first one is the <code class="language-plaintext highlighter-rouge">compiler</code>. The <code class="language-plaintext highlighter-rouge">compiler</code> is like central dispatch for Webpack. The hooks for <code class="language-plaintext highlighter-rouge">compiler</code> are very top-level, they control when Webpack starts, when Webpack is finished bundling, when Webpack is about to emit assets, before Webpack compiles, when Webpack is in watch mode, etc. To access any other [Tapable] instance, you have to go through the <code class="language-plaintext highlighter-rouge">compiler</code>.</p>

<p>The second [Tapable] instance is <code class="language-plaintext highlighter-rouge">compilation</code> AKA the dependency graph. The <code class="language-plaintext highlighter-rouge">compilation</code> instance is probably the most complicated instance in Webpack, being the heart of everything that happens in Webpack. The <code class="language-plaintext highlighter-rouge">compilation</code> instance is where Webpack builds, seals, and renders the dependency graph.</p>

<h3 id="resolver--module-factories">Resolver &amp; Module Factories</h3>

<p>The <code class="language-plaintext highlighter-rouge">resolver</code> instance is used to resolve partial paths and make sure they exist, then give you the full path. An example of this is when you are using a <code class="language-plaintext highlighter-rouge">require</code> statement. The <code class="language-plaintext highlighter-rouge">resolver</code> instance will look at the <code class="language-plaintext highlighter-rouge">require</code> statement, find the file and return the ‚Äòfull‚Äô request object with its path, context, request, and results defined. This information is then used to provide other parts of Webpack that need this information. The <code class="language-plaintext highlighter-rouge">resolver</code> instance is in the <code class="language-plaintext highlighter-rouge">node_modules</code> folder under <code class="language-plaintext highlighter-rouge">enhanced-resolver</code> because Webpack. Actually, Webpack chose to bundle the <code class="language-plaintext highlighter-rouge">enhanced-resolver</code> as a separate package so you could use it even if you aren‚Äôt (God forbid) using Webpack.</p>

<p>The <code class="language-plaintext highlighter-rouge">module factories</code> instance creates module instances in Webpack. The <code class="language-plaintext highlighter-rouge">module factories</code> (there are 2) take successfully resolved requests (all the information that the resolver provides) and collects the source code for that file, creating a module object.</p>

<h3 id="parser--templates">Parser &amp; Templates</h3>

<p>The <code class="language-plaintext highlighter-rouge">parser</code> instance takes strings of source code and turns them into Abstract Syntax Trees. Webpack uses Acorn as their syntax parser by default <a href="https://astexplorer.net/">go to astexlporer.net to see an AST</a>. Webpack uses the output from the <code class="language-plaintext highlighter-rouge">parser</code> instance to understand exactly what code looks like and how it works. The <code class="language-plaintext highlighter-rouge">parser</code> takes a module object, turns it into an AST to parse, finds all <code class="language-plaintext highlighter-rouge">require</code> and <code class="language-plaintext highlighter-rouge">import</code> statements and creates dependencies. The dependency objects are then attached to the module object.</p>

<p>The last Tapable instance is <code class="language-plaintext highlighter-rouge">template</code>. Templates take care of data binding for your module objects. Templates create the code you see in your bundles. In Webpack, a <code class="language-plaintext highlighter-rouge">chunk</code> is something that contains modules in an array, which allows Webpack to keep track of it. Each type of abstraction, a chunk, a module, a dependency, they all have templates. They are literally called; chunk template, module template, dependency template. This is for the runtime code. The main template generates the runtime, the chunk template generates the array brackets for each module, and the module template creates the IFFEs for each module around the function. The dependency template transforms the dependences into a <code class="language-plaintext highlighter-rouge">__webpack_require__</code> or dynamic import into a <code class="language-plaintext highlighter-rouge">__webpack_require__.e</code>, or whatever the appropriate transformation is for them.</p>

<h3 id="compiler-walkthrough">Compiler Walkthrough</h3>

<p>Pass the configuration to Webpack, it consumes it and reads the entry property. Not knowing whether that entry exists, Webpack goes through the module factory, which calls the resolver and asks if it exists. The resolver searches, if it finds it returns the full path information and some other context and useful data and passes it back to the module factory. The module factory creates an object, collects the source information, and now Webpack has the source for the module. Then, Webpack takes that source and parses it into an AST. It walks through the graph looking for dependency statements, and as it finds them, it attaches them to the module. To resolve the dependency paths, each dependency is passed to the resolver. This process is repeated until there are no more dependencies to be resolved. That is the entirety of Webpack, how it  creates the graph. If there are loaders, they will functionally transform the files until they are JavaScript and then it parses and goes through the exact same process.</p>

<p>Here‚Äôs the same process, but outlined a little differently:</p>

<p><strong>How a Module gets to the browser with Webpack</strong></p>

<p>Module: ‚ÄúHi! I‚Äôm a module!! I can‚Äôt wait to work in the browser!</p>

<p>Compilation: ‚ÄúWhoa there!! Cool your jets, we need to get you into shape before you are ready for the ‚ÄòBig Stage‚Äô!!‚Äù</p>

<p>Compilation: ‚ÄúFirst, I‚Äôll need you to jump in this container called a <code class="language-plaintext highlighter-rouge">chunk</code>, I‚Äôll be throwing a lot of <code class="language-plaintext highlighter-rouge">plugins</code> at you and I don‚Äôt want to lose track of you.‚Äù</p>

<p>Compilation: ‚ÄúAlmost there, but we have a problem! Those require and import statements have to go!! The <code class="language-plaintext highlighter-rouge">parser</code> gave me special instructions for ‚Äòrendering‚Äô those dependencies you have!! Dependency Templates &amp; Dependency Factory‚Äù</p>

<p>Module: ‚ÄúI‚Äôm finally rendered!! Here I come browserland, I‚Äôm so ready!‚Äù</p>

<p>This is literally how Webpack works in its entirety.</p>

<p>Build the graph, optimize the graph, render the graph.</p>

<h3 id="plugin-system-code-walkthrough">Plugin System Code Walkthrough</h3>

<p>All of Webpack‚Äôs CLIs use the Node API. There are hundreds of properties that Webpack default to out of the box (see <code class="language-plaintext highlighter-rouge">WebpackOptionsDefaulter.js</code>). In that same file, is where the <code class="language-plaintext highlighter-rouge">modes</code> are implemented. In <code class="language-plaintext highlighter-rouge">WebpackOptionsApply.js</code> the config and compiler instance are taken and are run in what is basically a giant <code class="language-plaintext highlighter-rouge">switch</code> statement which is looking for different properties in the config and determining which set of templates to run it against. In this same file is where the entry option is triggered <code class="language-plaintext highlighter-rouge">compiler.hooks.entryOption.call(options.context, options.entry);</code>, see <code class="language-plaintext highlighter-rouge">EntryOptionPlugin.js</code>. In the <code class="language-plaintext highlighter-rouge">parser</code> instance, Webpack emits an event for every type of variable from the AST. Webpack literally has plugins for every individual type of statement that exists in  Webpack, so events are firing in the thousands, tens of thousands, and hundreds of thousands because for every piece of the AST it is going to fire an event.</p>

<p>The best way of learning how to write Webpack plugins is to look at their source code.</p>

<h2 id="creating-plugins">Creating Plugins</h2>

<h3 id="creating-a-webpack-plugin">Creating a Webpack Plugin</h3>

<p>In its most basic form, a plugin is just a class that has an apply method. Continuing in the repo from the <a href="/frontend-masters/webpack-4-fundamentals">Webpack 4 Fundamentals workshop</a> or if you are only reading this document, <a href="https://github.com/TheLarkInn/webpack-workshop-2018/tree/feature/0504-webpack-prefetch-preload">grab the repo here</a>, create a new file in the <code class="language-plaintext highlighter-rouge">build-utils</code> folder called <code class="language-plaintext highlighter-rouge">MyFirstWebpackPlugin.js</code> (<code class="language-plaintext highlighter-rouge">...WebpackPlugin...</code> is a naming convention that Webpack follows). In that <code class="language-plaintext highlighter-rouge">MyFirstWebpackPlugin.js</code> file, add the following:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">class</span> <span class="nx">MyFirstWebpackPlugin</span> <span class="p">{</span>
    <span class="nx">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span> 
        <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nx">tapAsync</span><span class="p">(</span><span class="dl">"</span><span class="s2">MyFirstWebpackPlugin</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">stats</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// check out the node_modules/webpack/lib/Compiler.js file for a complete list of hooks</span>
            <span class="c1">// tapAsync is the API for tapping in, the first argument should be the name of your plugin, then stats (the object we want to look at), and a callback which is required because it is async</span>
            <span class="kd">const</span> <span class="nx">assetNames</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">assetName</span> <span class="k">in</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">compilation</span><span class="p">.</span><span class="nx">assets</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">assetNames</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">assetName</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">assetNames</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">));</span>
            <span class="nx">callback</span><span class="p">();</span> <span class="c1">// if you don't callback, Webpack won't run</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyFirstWebpackPlugin</span><span class="p">;</span></code></pre></figure>

<p>And in your <code class="language-plaintext highlighter-rouge">webpack.config.js</code> file add:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">//..</span>
<span class="kd">const</span> <span class="nx">MyFirstWebpackPlugin</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./build-utils/MyFirstWebpackPlugin</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="nl">plugins</span><span class="p">:</span> <span class="p">[</span>
    <span class="k">new</span> <span class="nx">MyFirstWebpackPlugin</span><span class="p">()</span>
<span class="p">]</span>
<span class="c1">//...</span></code></pre></figure>

<p>Now when you run <code class="language-plaintext highlighter-rouge">npm run prod</code>, in addition to the standard Webpack terminal logs, you should see the names of your assets output (somewhere) in the terminal. Try just logging stats and check out the object it returns, it contains all of the information about your build.</p>

<h3 id="plugin-instance-hooks">Plugin Instance Hooks</h3>

<p>Let‚Äôs look at how to plug in to something that is not the compiler! If you want to plug in to a different instance, you still have to go through the compiler. In <code class="language-plaintext highlighter-rouge">MyFirstWebpackPlugin.js</code> update your code like so:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">class</span> <span class="nx">MyFirstWebpackPlugin</span> <span class="p">{</span>
    <span class="nx">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span> <span class="p">{</span> 
        <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nx">tapAsync</span><span class="p">(</span><span class="dl">"</span><span class="s2">MyFirstWebpackPlugin</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">stats</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// check out the node_modules/webpack/lib/Compiler.js file for a complete list of hooks</span>
            <span class="c1">// tapAsync is the API for tapping in, the first argument should be the name of your plugin, then stats (the object we want to look at), and a callback which is required because it is async</span>
            <span class="kd">const</span> <span class="nx">assetNames</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">assetName</span> <span class="k">in</span> <span class="nx">stats</span><span class="p">.</span><span class="nx">compilation</span><span class="p">.</span><span class="nx">assets</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">assetNames</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">assetName</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">assetNames</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">));</span>
            <span class="nx">callback</span><span class="p">();</span> <span class="c1">// if you don't callback, Webpack won't run</span>
        <span class="p">});</span>

        <span class="nx">compiler</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">compilation</span><span class="p">.</span><span class="nx">tap</span><span class="p">(</span><span class="dl">"</span><span class="s2">MyFirstWebpackPlugin</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">compilation</span><span class="p">,</span> <span class="nx">params</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// the compilation hook is synchronous</span>
        <span class="kd">const</span> <span class="nx">ThisCompilation</span> <span class="o">=</span> <span class="nx">compilation</span><span class="p">;</span>
            <span class="nx">compilation</span><span class="p">.</span><span class="nx">hooks</span><span class="p">.</span><span class="nx">seal</span><span class="p">.</span><span class="nx">tap</span><span class="p">(</span><span class="dl">"</span><span class="s2">MyFirstWebpackPlugin</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">ThisCompilation</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">MyFirstWebpackPlugin</span><span class="p">;</span></code></pre></figure>

<p>For more details about the available hooks see the <a href="https://webpack.js.org/api/plugins/">Webpack Plugin API Documentation</a>. Loaders are also applied with a plugin‚Ä¶ <code class="language-plaintext highlighter-rouge">LoaderPlugin.js</code></p>

<h3 id="isolating-plugins">Isolating Plugins</h3>

<p>Here is some information about how Webpack abstracts things in their source code. Because everything in Webpack is so decoupled and abstracted, you could take anything, like a MongoDB database, or some online service database and as long as you implement the right adapter, so that it works like <a href="https://nodejs.org/api/fs.html">fs</a>, you could hook into the compiler and set <code class="language-plaintext highlighter-rouge">compiler.inputFileSystem</code> and <code class="language-plaintext highlighter-rouge">compiler.outputFileSystem</code> to these values. Technically, because Webpack‚Äôs resolver is in a separate package, if you felt the motivation to write an entirely separate resolver, you could.</p>

<p>The most basic explanation of how to make a Webpack plugin is to hook into a bunch of [Webpack] hooks. Webpack isolates the feature sets for each plugin. If they no longer wanted to support CommonJS, they could just remove the <code class="language-plaintext highlighter-rouge">CommonJsPlugin.js</code> file from their repo and they would no longer support CommonJS.</p>

<h2 id="config-loaders--babel">Config, Loaders, &amp; Babel</h2>

<h3 id="creating-a-custom-loader">Creating a Custom Loader</h3>

<p>To write a custom loader and develop it locally, you just need a couple of pieces. One of the pieces is a property called <code class="language-plaintext highlighter-rouge">resolveLoader</code>, the properties of which are identical to the <code class="language-plaintext highlighter-rouge">resolve</code> property. Any custom behavior that you want to apply to resolving modules, you can do the same thing for your loaders. A simple JS loader (filename: <code class="language-plaintext highlighter-rouge">webpack.myloader.js</code>) would look something like this:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">resolveLoader</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">alias</span><span class="p">:</span> <span class="p">{</span>
            <span class="dl">"</span><span class="s2">my-loader</span><span class="dl">"</span><span class="p">:</span> <span class="nx">require</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="dl">"</span><span class="s2">./build-utils/my-loader.js</span><span class="dl">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="na">module</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">rules</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="na">test</span><span class="p">:</span> <span class="sr">/</span><span class="se">\.</span><span class="sr">js/</span><span class="p">,</span>
                <span class="na">use</span><span class="p">:</span> <span class="dl">"</span><span class="s2">my-loader</span><span class="dl">"</span>
            <span class="p">}</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<p>Now you actually have to build the loader‚Ä¶ make a new file, following the path above <code class="language-plaintext highlighter-rouge">my-loader.js</code>, and insert the following:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">myLoader</span><span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// this is the basic anatomy of a loader. It takes a function which requires the `source` argument, then returns the `source`</span>
    <span class="k">return</span> <span class="nx">source</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">myLoader</span><span class="p">;</span></code></pre></figure>

<p>There is a ton of additional information about the <a href="https://webpack.js.org/api/loaders">loader API in the Webpack documentation</a>.</p>

<h3 id="configuring-babel-for-webpack">Configuring Babel for Webpack</h3>

<p>Since Webpack 2, Webpack has supported ES Modules out-of-the-box. A common pitfall is that people will have presets like Babel preset 2015, which by default compiles ES Modules into CommonJS syntax. This is a problem, because you are effectively opting out of every Webpack optimization. Webpack will not scope-hoist, tree-shake, or do much of anything with CommonJS Modules. In terms of supported syntax, Webpack is able to support any syntax that Acorn has adopted (generally stage 4 syntax). When in doubt, check the Acorn documentation.</p>

<h3 id="webpack-dev-kit--wrap-up">Webpack Dev Kit &amp; Wrap Up</h3>

<p>One additional resource that is useful is the <a href="https://github.com/TheLarkinn/webpack-developer-kit">Webpack Developer Kit</a>. The Webpack Developer Kit was created by the instructor (Sean Larkin) and is a tool to develop plugins and loaders. Clone it, fork it, use it!</p>
:ET